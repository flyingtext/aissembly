from .optimizations.accuracy_opt_passes import accuracy_opt_passes_optimization
from .optimizations.decomposition_opt_passes import decomposition_opt_passes_optimization

def _identity(program):
    """Placeholder optimization that returns the program unchanged."""
    return program

# "[EBNF of Aissembly Language]\n(* =========================================================\n   Aissembly Language \u2014 Minimal Formal Grammar (EBNF)\n   Terminals are in \"double quotes\". {} = zero or more,\n   [] = optional, | = alternation, () = grouping.\n   ========================================================= *)\n\nprogram        = { statement } ;\n\n(* ---------- Statements ---------- *)\nstatement      = var_assign\n               | aug_assign\n               | fn_def\n               | if_stmt\n               | while_stmt\n               | for_in_stmt\n               | return_stmt\n               | expr_stmt\n               ;\n\nvar_assign     = identifier \"=\" expression ;\naug_op         = \"+=\" | \"-=\" | \"*=\" | \"/=\" | \"%=\" ;\naug_assign     = identifier aug_op expression ;\n\nfn_def         = \"fn\" identifier \"(\" [ param_list ] \")\" block ;\nparam_list     = identifier { \",\" identifier } ;\n\nif_stmt        = \"if\" expression block [ \"else\" block ] ;\nwhile_stmt     = \"while\" expression block ;\nfor_in_stmt    = \"for\" identifier \"in\" expression block ;\n\nreturn_stmt    = \"return\" [ expression ] ;\nexpr_stmt      = expression ;\n\nblock          = \"{\" { statement } \"}\" ;\n\n(* ---------- Expressions (precedence: low \u2192 high) ---------- *)\nexpression     = or_expr ;\n\nor_expr        = and_expr { \"or\" and_expr } ;\nand_expr       = not_expr { \"and\" not_expr } ;\nnot_expr       = [ \"not\" ] compare_expr ;\n\ncompare_expr   = membership_expr\n                 { comp_op membership_expr } ;\ncomp_op        = \"==\" | \"!=\" | \"<\" | \">\" | \"<=\" | \">=\" ;\n\nmembership_expr = additive_expr\n                  { \"in\" additive_expr } ;\n\nadditive_expr  = multiplicative_expr\n                 { (\"+\" | \"-\") multiplicative_expr } ;\n\nmultiplicative_expr\n               = unary_expr { (\"*\" | \"/\" | \"%\") unary_expr } ;\n\nunary_expr     = [ (\"+\" | \"-\" ) ] postfix_expr ;\n\npostfix_expr   = primary_expr\n                 { call_suffix\n                 | index_suffix\n                 | member_suffix\n                 } ;\n\ncall_suffix    = \"(\" [ arg_list ] \")\" ;\narg_list       = expression { \",\" expression } ;\n\nindex_suffix   = \"[\" expression \"]\" ;\nmember_suffix  = \".\" identifier ;\n\nprimary_expr   = literal\n               | identifier\n               | list_lit\n               | dict_lit\n               | \"(\" expression \")\"\n               ;\n\n(* ---------- Literals ---------- *)\nliteral        = number | string | boolean | null ;\n\nlist_lit       = \"[\" [ expression { \",\" expression } [ \",\" ] ] \"]\" ;\n\ndict_lit       = \"{\"\n                   [ dict_entry { \",\" dict_entry } [ \",\" ] ]\n                 \"}\" ;\ndict_entry     = dict_key \":\" expression ;\ndict_key       = identifier | string ;\n\nboolean        = \"true\" | \"false\" ;\nnull           = \"null\" ;\n\n(* ---------- Lexical ---------- *)\nidentifier     = ident_start { ident_part } ;\nident_start    = letter | \"_\" ;\nident_part     = letter | digit | \"_\" ;\n\nnumber         = int | float ;\nint            = digit { digit } ;\nfloat          = int \".\" digit { digit } [ exp ] | \".\" digit { digit } [ exp ] | int exp ;\nexp            = (\"e\" | \"E\") [ \"+\" | \"-\" ] digit { digit } ;\n\nstring         = dq_string | sq_string ;\ndq_string      = \"\"\" { dq_char } \"\"\" ;\nsq_string      = \"'\"  { sq_char } \"'\"  ;\n\nletter         = \"A\" | ... | \"Z\" | \"a\" | ... | \"z\" ;\ndigit          = \"0\" | \"1\" | \"2\" | \"3\" | \"4\" | \"5\" | \"6\" | \"7\" | \"8\" | \"9\" ;\n\n(* ---------- Trivia (ignored by parser) ---------- *)\nwhitespace     = { \" \" | \"\t\" | \"\r\" | \"\n\" } ;\ncomment        = \"#\" { any_char_except_newline } ( \"\n\" | EOF ) ;\n\n(* The lexer should skip whitespace and comments between tokens.\n   Statements are separated by newlines or block delimiters; semicolons are optional. *)\n\n(* ---------- Reserved Words ---------- *)\n(* \"fn\", \"if\", \"else\", \"while\", \"for\", \"in\",\n   \"return\", \"and\", \"or\", \"not\",\n   \"true\", \"false\", \"null\" are reserved and cannot be identifiers. *)"

def optimizer(program, options) :
    for _ in range(options.accuracy_opt_passes):
        program = accuracy_opt_passes_optimization(options, program)
    for _ in range(options.decomposition_opt_passes):
        program = decomposition_opt_passes_optimization(options, program)
    for _ in range(options.integration_opt_passes):
        program = _identity(program)
    for _ in range(options.loop_to_operation_opt_passes):
        program = _identity(program)
    for _ in range(options.operation_to_loop_opt_passes):
        program = _identity(program)
    for _ in range(options.condition_to_operation_opt_passes):
        program = _identity(program)

    return program